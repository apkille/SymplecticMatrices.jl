var documenterSearchIndex = {"docs":
[{"location":"#SymplecticMatrices.jl","page":"SymplecticMatrices.jl","title":"SymplecticMatrices.jl","text":"","category":"section"},{"location":"","page":"SymplecticMatrices.jl","title":"SymplecticMatrices.jl","text":"A package for the handling of symplectic matrices.","category":"page"},{"location":"API/#Full-API","page":"Full API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"Full API","title":"Full API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"Full API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#SymplecticMatrices.BlochMessiah","page":"Full API","title":"SymplecticMatrices.BlochMessiah","text":"BlochMessiah <: Factorization\n\nMatrix factorization type of the Bloch-Messiah/Euler decomposition of a symplectic matrix S. This is the return type of blochmessiah(_), the corresponding matrix factorization function.\n\nIf F::BlochMessiah is the factorization object, O, values and Qcan be obtained viaF.O,F.values, andF.Q`.\n\nIterating the decomposition produces the components O, values, and Q, in that order.\n\nExamples\n\njulia> S = Symplectic(BlockForm(1), [1. 1.; 0. 1.])\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n 1.0  1.0\n 0.0  1.0\n\njulia> issymplectic(S)\ntrue\n\njulia> F = blochmessiah(S)\nBlochMessiah{Float64, Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}, Vector{Float64}}\nO factor:\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n 0.850651  -0.525731\n 0.525731   0.850651\nvalues:\n1-element Vector{Float64}:\n 1.618033988749895\nQ factor:\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n  0.525731  0.850651\n -0.850651  0.525731\n\njulia> isapprox(S, F.O * Diagonal(vcat(F.values, F.values .^ (-1))) * F.Q, atol = 1e-10)\ntrue\n\njulia> issymplectic(F.O, atol = 1e-10) && issymplectic(F.Q, atol = 1e-10)\ntrue\n\njulia> O, values, Q = F; # destructuring via iteration\n\njulia> O == F.O && values == F.values && Q == F.Q\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API/#SymplecticMatrices.Polar","page":"Full API","title":"SymplecticMatrices.Polar","text":"Polar <: Factorization\n\nMatrix factorization type of the polar decomposition of a symplectic matrix S. This is the return type of polar(_), the corresponding matrix factorization function.\n\nIf F::Polar is the factorization object, O and P can be obtained via F.O and F.P, such that S = O * P.\n\nIterating the decomposition produces the components O and P.\n\nExamples\n\njulia> S = [1. 1.; 0. 1.]\n2×2 Matrix{Float64}:\n 1.0  1.0\n 0.0  1.0\n\njulia> issymplectic(BlockForm(1), S)\ntrue\n\njulia> F = polar(S)\nPolar{Float64, Matrix{Float64}, Matrix{Float64}}\nO factor:\n2×2 Matrix{Float64}:\n  0.894427  0.447214\n -0.447214  0.894427\nP factor:\n2×2 Matrix{Float64}:\n 0.894427  0.447214\n 0.447214  1.34164\n\njulia> isapprox(F.O * F.P, S)\ntrue\n\njulia> O, P = F; # destructuring via iteration\n\njulia> O == F.O && P == F.P\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API/#SymplecticMatrices.Symplectic-Union{Tuple{D}, Tuple{F}, Tuple{F, D}} where {F<:SymplecticMatrices.SymplecticForm, D<:(AbstractMatrix)}","page":"Full API","title":"SymplecticMatrices.Symplectic","text":"Symplectic(J::SymplecticForm, S::AbstractMatrix) <: AbstractMatrix\n\nConstruct a wrapper of a symplectic matrix S with its corresponding symplectic basis defined by the symplectic form J.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticMatrices.Williamson","page":"Full API","title":"SymplecticMatrices.Williamson","text":"Williamson <: Factorization\n\nMatrix factorization type of the williamson decomposition of a positive-definite matrix V. This is the return type of williamson(_), the corresponding matrix factorization function.\n\nIf F::Williamson is the factorization object, S and spectrum can be obtained via F.S and F.spectrum.\n\nIterating the decomposition produces the components S and spectrum.\n\nExamples\n\njulia> V = [7. 2.; 2. 1.]\n2×2 Matrix{Float64}:\n 7.0  2.0\n 2.0  1.0\n\njulia> isposdef(V)\ntrue\n\njulia> F = williamson(BlockForm(1), V)\nWilliamson{Float64, Matrix{Float64}, Vector{Float64}}\nS factor:\n2×2 Matrix{Float64}:\n 0.448828  -1.95959\n 0.61311   -0.448828\nsymplectic spectrum:\n1-element Vector{Float64}:\n 1.7320508075688772\n\njulia> isapprox(F.S * V * F.S', Diagonal(repeat(F.spectrum, 2)))\ntrue\n\njulia> S, spectrum = F; # destructuring via iteration\n\njulia> S == F.S && spectrum == F.spectrum\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API/#SymplecticMatrices.blochmessiah-Union{Tuple{Symplectic{F, T, D}}, Tuple{D}, Tuple{T}, Tuple{F}} where {F<:SymplecticMatrices.SymplecticForm, T, D<:AbstractMatrix{T}}","page":"Full API","title":"SymplecticMatrices.blochmessiah","text":"blochmessiah(form::SymplecticForm, S::AbstractMatrix) -> BlochMessiah\nblochmessiah(S::Symplectic) -> BlochMessiah\n\nCompute the Bloch-Messiah/Euler decomposition of a symplectic matrix S and return a BlockMessiah object.\n\nThe orthogonal symplectic matrices O and Q as well as the singular values values can be obtained via F.O, F.Q, and F.values, respectively.\n\nIterating the decomposition produces the components O, values, and Q, in that order.\n\nExamples\n\njulia> S = Symplectic(BlockForm(1), [1. 1.; 0. 1.])\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n 1.0  1.0\n 0.0  1.0\n\njulia> issymplectic(S)\ntrue\n\njulia> F = blochmessiah(S)\nBlochMessiah{Float64, Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}, Vector{Float64}}\nO factor:\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n 0.850651  -0.525731\n 0.525731   0.850651\nvalues:\n1-element Vector{Float64}:\n 1.618033988749895\nQ factor:\n2×2 Symplectic{BlockForm{Int64}, Float64, Matrix{Float64}}:\n  0.525731  0.850651\n -0.850651  0.525731\n\njulia> isapprox(S, F.O * Diagonal(vcat(F.values, F.values .^ (-1))) * F.Q, atol = 1e-10)\ntrue\n\njulia> issymplectic(F.O, atol = 1e-10) && issymplectic(F.Q, atol = 1e-10)\ntrue\n\njulia> O, values, Q = F; # destructuring via iteration\n\njulia> O == F.O && values == F.values && Q == F.Q\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticMatrices.issymplectic-Union{Tuple{R2}, Tuple{R1}, Tuple{T}, Tuple{SymplecticMatrices.SymplecticForm, T}} where {T<:(AbstractMatrix), R1<:Real, R2<:Real}","page":"Full API","title":"SymplecticMatrices.issymplectic","text":"issymplectic(form::Symplecticform, x::AbstractMatrix; atol=0.0, rtol=atol)\nissymplectic(x::Symplectic; atol=0.0, rtol=atol)\n\nReturn whether or not an input matrix is symplectic. Keyword arguments atol and rtol can be called to determine absolute and relative tolerances of the check, respectively.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticMatrices.polar-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Full API","title":"SymplecticMatrices.polar","text":"polar(S::AbstractMatrix) -> Polar\npolar(S::Symplectic) -> Polar\n\nCompute the polar decomposition of a symplectic matrix S and return a Polar object.\n\nO and P can be obtained from the factorization F via F.O and F.P, such that S = O * P. For the symplectic polar decomposition case, O is an orthogonal symplectic matrix and P is a positive-definite symmetric symplectic matrix.\n\nIterating the decomposition produces the components O and P.\n\nExamples\n\njulia> S = [1. 1.; 0. 1.]\n2×2 Matrix{Float64}:\n 1.0  1.0\n 0.0  1.0\n\njulia> issymplectic(BlockForm(1), S)\ntrue\n\njulia> F = polar(S)\nPolar{Float64, Matrix{Float64}, Matrix{Float64}}\nO factor:\n2×2 Matrix{Float64}:\n  0.894427  0.447214\n -0.447214  0.894427\nP factor:\n2×2 Matrix{Float64}:\n 0.894427  0.447214\n 0.447214  1.34164\n\njulia> isapprox(F.O * F.P, S)\ntrue\n\njulia> O, P = F; # destructuring via iteration\n\njulia> O == F.O && P == F.P\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticMatrices.randsymplectic-Union{Tuple{SymplecticMatrices.SymplecticForm{N}}, Tuple{N}} where N<:Int64","page":"Full API","title":"SymplecticMatrices.randsymplectic","text":"randsymplectic(form::SymplecticForm)\nrandsymplectic(::Symplectic, form::SymplecticForm)\n\nCalculate a random symplectic matrix in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticMatrices.williamson-Union{Tuple{T}, Tuple{F}, Tuple{F, AbstractMatrix{T}}} where {F<:SymplecticMatrices.SymplecticForm, T<:Real}","page":"Full API","title":"SymplecticMatrices.williamson","text":"williamson(form::SymplecticForm, V::AbstractMatrix) -> Williamson\nwilliamson(::Symplectic, form::SymplecticForm, V::AbstractMatrix) -> Williamson\n\nCompute the williamson decomposition of a positive-definite matrix V and return a Williamson object.\n\nA symplectic matrix S and symplectic spectrum spectrum can be obtained via F.S and F.spectrum.\n\nIterating the decomposition produces the components S and spectrum.\n\nExamples\n\njulia> V = [7. 2.; 2. 1.]\n2×2 Matrix{Float64}:\n 7.0  2.0\n 2.0  1.0\n\njulia> isposdef(V)\ntrue\n\njulia> F = williamson(BlockForm(1), V)\nWilliamson{Float64, Matrix{Float64}, Vector{Float64}}\nS factor:\n2×2 Matrix{Float64}:\n 0.448828  -1.95959\n 0.61311   -0.448828\nsymplectic spectrum:\n1-element Vector{Float64}:\n 1.7320508075688772\n\njulia> isapprox(F.S * V * F.S', Diagonal(repeat(F.spectrum, 2)))\ntrue\n\njulia> S, spectrum = F; # destructuring via iteration\n\njulia> S == F.S && spectrum == F.spectrum\ntrue\n\n\n\n\n\n","category":"method"}]
}
